/*************************************************************************\
 * Copyright (c) 2002 The University of Chicago, as Operator of Argonne
 * National Laboratory.
 * Copyright (c) 2002 The Regents of the University of California, as
 * Operator of Los Alamos National Laboratory.
 * This file is distributed subject to a Software License Agreement found
 * in the file LICENSE that is included with this distribution. 
\*************************************************************************/

/* program: sddswput.c
 * purpose: reads a file and sends out waveform data to PVs
 * input: a file like that generated by sddswget.
 *      Parameters: WaveformPV (string)
 *      Columns: Waveform (float or double)
 * 
 * Michael Borland, 2001.
 */
#include "mdb.h"
#include "scan.h"
#include "match_string.h"
#include "SDDS.h"
#include "SDDSepics.h"

#ifdef _WIN32
#  include <windows.h>
#  define usleep(usecs) Sleep(usecs / 1000)
#  define sleep(sec) Sleep(sec * 1000)
#else
#  include <unistd.h>
#endif

#define CLO_PENDIOTIME 0
#define CLO_PIPE 1
#define COMMANDLINE_OPTIONS 2
char *commandline_option[COMMANDLINE_OPTIONS] = {
  "pendiotime",
  "pipe",
};

static char *USAGE1 = "sddswput <inputfile>\n\
    [-pendIOtime=<seconds>] [-pipe[=input]] \n\n\
Reads waveform data from an SDDS file and writes the values to EPICS process variables.\n\
<inputfile>        A file like that generated by sddswget.\n\
                   Has a parameter WaveformPV (string type) and\n\
                   a column Waveform (numerical type).\n\
pipe               read input file from pipe. it can only be -pipe or -pipe=input. \n\
Program by M. Borland.\n\
Link date: "__DATE__
                      " "__TIME__
                      ", SVN revision: " SVN_VERSION ", " EPICS_VERSION_STRING "\n";

typedef struct
{
  char *name;
  long size;
  long index; /* index in the target data set */
  short doCopy;
} SOURCE_DATA;

volatile int sigint = 0;

int main(int argc, char **argv) {
  SCANNED_ARG *scArg;
  SDDS_TABLE SDDSin;
  char *inputfile;
  char **waveformPV;
  chid *waveformCHID = NULL;
  long waveforms;
  long *waveformLength;
  void **waveformData;
  long *waveformDataType;
  long i_arg, i, index;
  double pendIOtime = 10.0;
  unsigned long pipeFlags = 0;

  SDDS_RegisterProgramName(argv[0]);
  SDDS_CheckDatasetStructureSize(sizeof(SDDS_DATASET));

  argc = scanargs(&scArg, argc, argv);
  if (argc == 1) {
    fprintf(stderr, "%s\n", USAGE1);
    exit(1);
  }

  inputfile = NULL;
  waveformPV = NULL;
  waveforms = 0;

  for (i_arg = 1; i_arg < argc; i_arg++) {
    if (scArg[i_arg].arg_type == OPTION) {
      delete_chars(scArg[i_arg].list[0], "_");
      switch (match_string(scArg[i_arg].list[0], commandline_option, COMMANDLINE_OPTIONS, 0)) {
      case CLO_PENDIOTIME:
        if (scArg[i_arg].n_items != 2 || sscanf(scArg[i_arg].list[1], "%lf", &pendIOtime) != 1 ||
            pendIOtime <= 0)
          bomb("invalid -pendIOtime syntax\n", NULL);
        break;
      case CLO_PIPE:
        if (!processPipeOption(scArg[i_arg].list + 1, scArg[i_arg].n_items - 1, &pipeFlags))
          bomb("invalid -pipe syntax", NULL);
        if (pipeFlags == USE_STDOUT)
          bomb("invalid -pipe syntax, should be -pipe or -pipe=input", NULL);
        break;
      default:
        fprintf(stderr, "unrecognized option given: %s.\n", scArg[i_arg].list[0]);
        exit(1);
      }
    } else {
      if (!inputfile)
        inputfile = scArg[i_arg].list[0];
      else
        bomb("too many filenames given", NULL);
    }
  }
  if (!inputfile && !(pipeFlags & USE_STDIN))
    SDDS_Bomb("no input filename");
  if (inputfile && pipeFlags)
    SDDS_Bomb("too many filenames given");
  if (!SDDS_InitializeInput(&SDDSin, inputfile))
    SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);
  /*
    if ((SDDS_CHECK_OKAY!=SDDS_CheckColumn(&SDDSin, "Waveform", NULL, SDDS_ANY_NUMERIC_TYPE, stderr))) {
    SDDS_SetError("Missing column Waveform in input file");
    SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors|SDDS_EXIT_PrintErrors);
    } */
  if ((SDDS_CHECK_OKAY != SDDS_CheckParameter(&SDDSin, "WaveformPV", NULL, SDDS_STRING, stderr))) {
    SDDS_SetError("Missing parameter Waveform in input file");
    SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);
  }

  waveformData = NULL;
  waveformLength = NULL;
  waveformPV = NULL;
  waveformDataType = NULL;
  waveforms = 0;
  index = 0;
  while (SDDS_ReadPage(&SDDSin) > 0) {
    if (!(waveformData = SDDS_Realloc(waveformData, sizeof(*waveformData) * (waveforms + 1))) ||
        !(waveformPV = SDDS_Realloc(waveformPV, sizeof(*waveformPV) * (waveforms + 1))) ||
        !(waveformCHID = SDDS_Realloc(waveformCHID, sizeof(*waveformCHID) * (waveforms + 1))) ||
        !(waveformLength = SDDS_Realloc(waveformLength, sizeof(*waveformLength) * (waveforms + 1))) ||
        !(waveformDataType = SDDS_Realloc(waveformDataType, sizeof(*waveformDataType) * (waveforms + 1))))
      SDDS_Bomb("memory allocation failure");
    if ((waveformLength[waveforms] = SDDS_RowCount(&SDDSin)) <= 0)
      continue;
    if ((index = SDDS_GetColumnIndex(&SDDSin, "Waveform")) < 0) {
      fprintf(stderr, "\"Waveform\" column does not exist.!");
      exit(1);
    }
    waveformDataType[waveforms] = SDDS_GetColumnType(&SDDSin, index);
    if (!(waveformData[waveforms] = SDDS_GetColumn(&SDDSin, "Waveform")) ||
        !SDDS_GetParameter(&SDDSin, "WaveformPV", waveformPV + waveforms))
      SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);
    waveforms++;
  }
  if (!SDDS_Terminate(&SDDSin))
    SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);
  ca_task_initialize();
  for (i = 0; i < waveforms; i++) {
    if (ca_search(waveformPV[i], &(waveformCHID[i])) != ECA_NORMAL) {
      fprintf(stderr, "error: problem doing search for %s\n", waveformPV[i]);
      ca_task_exit();
      exit(1);
    }
  }
  if (ca_pend_io(pendIOtime) != ECA_NORMAL) {
    fprintf(stderr, "error: problem doing search for some channels\n");
    for (i = 0; i < waveforms; i++) {
      if (ca_state(waveformCHID[i]) != cs_conn)
        fprintf(stderr, "%s not connected\n", waveformPV[i]);
    }
    ca_task_exit();
    exit(1);
  }
  for (i = 0; i < waveforms; i++) {
    if (DataTypeToCaType(waveformDataType[i]) == DBR_STRING) {
      char *stringwaveform = NULL;
      int n;
      stringwaveform = (char *)calloc(waveformLength[i], MAX_STRING_SIZE);
      for (n = 0; n < waveformLength[i]; n++) {
        strcpy(stringwaveform + n * MAX_STRING_SIZE, ((char **)(waveformData[i]))[n]);
      }
      if (ca_array_put(DataTypeToCaType(waveformDataType[i]), waveformLength[i],
                       waveformCHID[i], stringwaveform) != ECA_NORMAL) {
        fprintf(stderr, "error: problem setting %s\n", waveformPV[i]);
        ca_task_exit();
        exit(1);
      }
      free(stringwaveform);
    } else {
      if (ca_array_put(DataTypeToCaType(waveformDataType[i]), waveformLength[i],
                       waveformCHID[i], waveformData[i]) != ECA_NORMAL) {
        fprintf(stderr, "error: problem setting %s\n", waveformPV[i]);
        ca_task_exit();
        exit(1);
      }
    }
  }
  if (ca_pend_io(pendIOtime) != ECA_NORMAL) {
    fprintf(stderr, "error1: problem doing put for some channels\n");
    ca_task_exit();
    exit(1);
  }
  /*5/23/2013 H. Shang, added ca_pend_event() for PVs that are behind the gateway to prevent the client disconnect
    from gateway before the gateway actually do the put */
  oag_ca_pend_event(0.5, &sigint);
  if (sigint) {
    fprintf(stderr, "error2: problem doing put for some channels.\n");
    exit(1);
  }
  ca_task_exit();

  if (waveforms) {
    for (i = 0; i < waveforms; i++) {
      free(waveformPV[i]);
      free(waveformData[i]);
    }
    free(waveformData);
    free(waveformPV);
    free(waveformLength);
    free(waveformDataType);
    if (waveformCHID)
      free(waveformCHID);
  }
  free_scanargs(&scArg, argc);
  return 0;
}
