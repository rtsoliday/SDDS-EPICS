/*************************************************************************\
 * Copyright (c) 2002 The University of Chicago, as Operator of Argonne
 * National Laboratory.
 * Copyright (c) 2002 The Regents of the University of California, as
 * Operator of Los Alamos National Laboratory.
 * This file is distributed subject to a Software License Agreement found
 * in the file LICENSE that is included with this distribution. 
\*************************************************************************/

/* program: sddsSubstractDispersionOrbit.c
 * purpose: reads a file and sends out waveform data to PVs
 * input: a file like that generated by sddswget.
 *      Parameters: WaveformPV (string)
 *      Columns: Waveform (float or double)
 * 
 * Michael Borland, 2001.
 */
#include "mdb.h"
#include "scan.h"
#include "match_string.h"
#include "SDDS.h"
#include "SDDSepics.h"
#include <time.h>
#if !defined(vxWorks)
#  include <sys/timeb.h>
#endif
/*#include <chandata.h>*/
#include <signal.h>
#ifdef _WIN32
#  include <windows.h>
#  include <process.h>
#  define usleep(usecs) Sleep(usecs / 1000)
#else
#  include <unistd.h>
#endif
#include <alarm.h>
#if defined(vxWorks)
#  include <taskLib.h>
#  include <taskVarLib.h>
#  include <taskHookLib.h>
#  include <sysLib.h>
#endif

#ifdef _WIN32
#  include <windows.h>
#  define usleep(usecs) Sleep(usecs / 1000)
#  define sleep(sec) Sleep(sec * 1000)
#else
#  include <unistd.h>
#endif

#if defined(DBAccess)
#  include "dbDefs.h"
#  include "dbAccess.h"
#  include "errlog.h"
#  include "link.h"
#else
#  include <cadef.h>
#endif
#include <epicsVersion.h>

#ifdef USE_RUNCONTROL
#  include <libruncontrol.h>
#endif

#ifdef USE_LOGDAEMON
#  include <logDaemonLib.h>
#endif

void interrupt_handler(int sig);
void interrupt_handler2(int sig);
void sigint_interrupt_handler(int sig);
void rc_interrupt_handler();

#define CLO_PENDIOTIME 0
#define CLO_INTERVAL 1
#define CLO_RUNCONTROL 2
#define CLO_DRY_RUN 3
#define CLO_VERBOSE 4
#define CLO_STEPS 5
#define CLO_INFINITELOOP 6
#define CLO_SCR_FILE 7
#define CLO_RESPONSE_FILE 8
#define CLO_ID_SECTOR_FILE 9
#define CLO_BEAM_ENERGY 10
#define COMMANDLINE_OPTIONS 11
char *commandline_option[COMMANDLINE_OPTIONS] = {
  "pendiotime", "interval", "runControl", "dryRun", "verbose", "steps", "infiniteLoop", "SCRFile", "responseFile", "IDsectorFile", "beamEnergy"};

static char *USAGE1 = "sddsSubstractDispersionOrbit <inputfile>\n\
    [-pendIOtime=<seconds>] [-interval=<seconds>] [-runControl=pv=<string>,pingTimeOut=<value>,pingTimeInterval=<value>,description=<string>] \n\
    [-dryRun] [-verbose] [-steps=<integer>] [-SCRFile=<filename>] [-responseFile=<filename>] [-beamEnergy=<energy-in-GeV> \n\
sddsSubstractDispesionOrbit does following:\n\
SetpointAO <- SCR_SetpointAO + dispersionOrbitAO \n\
AdjustedWaveform <- SCR_SetpointAO + SCR_OffsetAO +  dispersionOrbitAO \n\
the dispersionOrbitAO is computed from dispersion (provided by the dispersion file) and energy loss. \n\n\
<inputfile>        A file like that contains adjust WaveformPV name, DeviceName and Index column.\n\
interval           provide the looping interval \n\
runcontrol         provide runcontrol pv information \n\
dryRun             if provided in dryRun mode, the waveform will not be updated.\n\
steps              number of steps to run.\n\
infiniteLoop       if given, it will run endless.\n\
SCRFile            provide the BPM setpoints and offsets, if not provided, the setpoint and offset will be read from ioc. \n\
responseFile       response matrix file for bpm setpoint vs. ID energy loss. (default file is /home/helios/oagData/sr/lattices/default/IDlossOrbitResponse) \n\
IDsectorFile       provided ID information. (default use  /home/helios/oagData/sr/IDs/sectors.sdds)\n\
verbose            print out the message \n\
beamEnergy         beam energy in GeV, default is 7 GeV\n\
Program by H. Shang.\n\
Link date: "__DATE__
                      " "__TIME__
                      ", SVN revision: " SVN_VERSION ", " EPICS_VERSION_STRING "\n";

typedef struct
{
  long step, steps, dryRun, verbose;
  double interval, *elapsedTime, *epochTime;
  char *searchPath;
  double pendIOTime;
  char *inputfile;
} LOOP_PARAM;

typedef struct
{
  double *waveformValue, *setpoint, *offset, *init_setpoint;
  char *waveformPV, **DeviceName;
  int32_t waveformRows, *bpmIndex;
  /*bpmIndex is the index of bpm in response matrix */
  chid waveformCID, *setpointID, *offsetID;
  short *isValid;
} WAVEFORM_DATA;

typedef struct {
  double **resp_data;
  double *delta_setpoint; /*computed from response matrix and energy loss */
  char **bpmName, **IDname;
  chid *energyID;
  double *totalPower;
  int32_t resp_rows, IDs;
  /*validIDs is the sum of valid ds and us ID */
  /*resp_data is in row order, one row for each bpm */
} RESPONSE_MATRIX;

#ifdef USE_RUNCONTROL
typedef struct
{
  char *PV, *Desc; /* name of run control PV and run control description PV */
  double pingInterval;
  float pingTimeout;
  char message[39], handle[256];
  long alarmSeverity;
  int status;
#  if !defined(vxWorks)
  RUNCONTROL_INFO rcInfo;
#  endif
} RUNCONTROL_PARAM;

RUNCONTROL_PARAM rcParam; /* need to be global because some quantities are used
                             in signal and interrupt handlers */

int runControlPingWhileSleep(double sleepTime, LOOP_PARAM *loopParam);
#endif

volatile int sigint = 0;

#define FPINFO stdout

void InitializeLoopParam(LOOP_PARAM *loopParam);

void readResponseDataAndIDsectorFile(char *respFile, char *IDsectorFile, RESPONSE_MATRIX *resp_matrix, double pendIOTime);

long readinputfile(char *inputfile, long *waveforms, WAVEFORM_DATA **waveformData, LOOP_PARAM *loopParam, char *SCRFile, RESPONSE_MATRIX *resp_matrix);
void free_waveform_memory(long waveforms, WAVEFORM_DATA *waveformData);
void free_response_memory(RESPONSE_MATRIX *resp_matrix);

int main(int argc, char **argv) {
#ifdef USE_RUNCONTROL
  unsigned long dummyFlags;
#endif
  SCANNED_ARG *scArg;
  long i_arg, i, j;
  LOOP_PARAM loopParam;
  long infinite = 0, waveforms = 0;
  WAVEFORM_DATA *waveformData = NULL;
  char *SCRFile = NULL, *responseFile = NULL, *IDsectorFile = NULL;
  double lastRCPingTime = 0.0, timeLeft, targetTime, startTime0, beamEnergy = 7;
  RESPONSE_MATRIX resp_matrix;

  startTime0 = getTimeInSecs();
  /*initialize rcParam */
#ifdef USE_RUNCONTROL
  rcParam.PV = rcParam.Desc = NULL;
  /* pingInterval should be short enough so
     that operators get a response from an abort command */
  rcParam.pingInterval = 2;
  rcParam.pingTimeout = 10;
  rcParam.alarmSeverity = NO_ALARM;
#endif
  signal(SIGINT, sigint_interrupt_handler);
  signal(SIGTERM, sigint_interrupt_handler);
  signal(SIGILL, interrupt_handler);
  signal(SIGABRT, interrupt_handler);
  signal(SIGFPE, interrupt_handler);
  signal(SIGSEGV, interrupt_handler);
#ifndef _WIN32
  signal(SIGHUP, interrupt_handler);
  signal(SIGQUIT, sigint_interrupt_handler);
  signal(SIGTRAP, interrupt_handler);
  signal(SIGBUS, interrupt_handler);
#endif

  SDDS_RegisterProgramName(argv[0]);

  argc = scanargs(&scArg, argc, argv);
  if (argc == 1) {
    fprintf(stderr, "%s\n", USAGE1);
    exit(1);
  }
  InitializeLoopParam(&loopParam);

  for (i_arg = 1; i_arg < argc; i_arg++) {
    if (scArg[i_arg].arg_type == OPTION) {
      delete_chars(scArg[i_arg].list[0], "_");
      switch (match_string(scArg[i_arg].list[0], commandline_option, COMMANDLINE_OPTIONS, 0)) {
      case CLO_PENDIOTIME:
        if (scArg[i_arg].n_items != 2 || sscanf(scArg[i_arg].list[1], "%lf", &loopParam.pendIOTime) != 1 ||
            loopParam.pendIOTime <= 0)
          bomb("invalid -pendIOtime syntax\n", NULL);
        break;
      case CLO_DRY_RUN:
        loopParam.dryRun = 1;
        break;
      case CLO_INTERVAL:
        if (scArg[i_arg].n_items != 2 || sscanf(scArg[i_arg].list[1], "%lf", &loopParam.interval) != 1 ||
            loopParam.interval <= 0)
          bomb("invalid -interval syntax\n", NULL);
        break;
      case CLO_BEAM_ENERGY:
        if (scArg[i_arg].n_items != 2)
          bomb("invalid -beamEnergy syntax\n", NULL);
        if (!get_double(&beamEnergy, scArg[i_arg].list[1]))
          SDDS_Bomb("Invalid value provided for beamEnergy!");
        break;
      case CLO_RUNCONTROL:
#ifdef USE_RUNCONTROL
        scArg[i_arg].n_items -= 1;
        if ((scArg[i_arg].n_items < 0) ||
            !scanItemList(&dummyFlags, scArg[i_arg].list + 1, &scArg[i_arg].n_items, 0,
                          "pv", SDDS_STRING, &rcParam.PV, 1, 0,
                          "pingTimeout", SDDS_FLOAT, &rcParam.pingTimeout, 1, 0,
                          "pingTimeInterval", SDDS_DOUBLE, &rcParam.pingInterval, 1, 0,
                          "description", SDDS_STRING, &rcParam.Desc, 1, 0,
                          NULL) ||
            !rcParam.PV)
          bomb("bad -runControlPV syntax", "-runcontrol=pv=<string>,pingTimeout=<value>,pingInterval=<value>,description=<string>");
        rcParam.pingTimeout *= 1000;
        if (rcParam.pingTimeout < 0) {
          fprintf(stderr, "Ping timeout for run control PV should be >= 0.");
          exit(1);
        }
        scArg[i_arg].n_items += 1;
#else
        fprintf(stderr, "runControl is not available. Option -runControlPV ignored.\n");
#endif
        break;
      case CLO_VERBOSE:
        loopParam.verbose = 1;
        break;
      case CLO_STEPS:
        if (scArg[i_arg].n_items != 2 || sscanf(scArg[i_arg].list[1], "%ld", &loopParam.steps) != 1 ||
            loopParam.steps <= 0)
          bomb("invalid -steps syntax\n", NULL);
        break;
      case CLO_INFINITELOOP:
        infinite = 1;
        break;
      case CLO_SCR_FILE:
        if (scArg[i_arg].n_items != 2)
          bomb("invalid -SCRFile syntax\n", NULL);
        SCRFile = scArg[i_arg].list[1];
        break;
      case CLO_RESPONSE_FILE:
        if (scArg[i_arg].n_items != 2)
          bomb("invalid -responseFile syntax\n", NULL);
        responseFile = scArg[i_arg].list[1];
        break;
      case CLO_ID_SECTOR_FILE:
        if (scArg[i_arg].n_items != 2)
          bomb("invalid -IDsectorFile syntax\n", NULL);
        IDsectorFile = scArg[i_arg].list[1];
        break;
      default:
        fprintf(stderr, "Unrecognized option given: %s.\n", scArg[i_arg].list[0]);
        exit(1);
      }
    } else {
      if (!loopParam.inputfile)
        loopParam.inputfile = scArg[i_arg].list[0];
      else
        bomb("Too many filenames given", NULL);
    }
  }
  if (infinite)
    loopParam.steps = INT_MAX;
  if (!loopParam.inputfile)
    SDDS_Bomb("no input filename");
  if (!responseFile)
    SDDS_CopyString(&responseFile, "/home/helios/oagData/sr/lattices/default/IDlossOrbitResponse");
  if (!IDsectorFile)
    SDDS_CopyString(&IDsectorFile, "/home/helios/oagData/sr/IDs/sectors.sdds");

#ifdef USE_RUNCONTROL
  if (rcParam.PV && !rcParam.Desc) {
    fprintf(stderr, "The runControl description should not be null!");
    exit(1);
  }
#endif
#ifdef USE_RUNCONTROL
  if (rcParam.PV) {
    if (loopParam.pendIOTime * 1000 > rcParam.pingTimeout) {
      /* runcontrol will time out if CA connection
         takes longer than its timeout, so the runcontrol ping timeout should be longer
         than the pendIOTime*/
      rcParam.pingTimeout = (loopParam.pendIOTime + 10) * 1000;
    }
    rcParam.handle[0] = (char)0;
    rcParam.Desc = (char *)realloc(rcParam.Desc, 41 * sizeof(char));
    rcParam.PV = (char *)realloc(rcParam.PV, 41 * sizeof(char));

    rcParam.status = runControlInit(rcParam.PV,
                                    rcParam.Desc,
                                    rcParam.pingTimeout,
                                    rcParam.handle,
                                    &(rcParam.rcInfo),
                                    30.0);
    if (rcParam.status != RUNCONTROL_OK) {
      fprintf(stderr, "Error initializing run control.\n");
      if (rcParam.status == RUNCONTROL_DENIED) {
        fprintf(stderr, "Another application instance is using the same runcontrol record,\n\tor has the same description string,\n\tor the runcontrol record has not been cleared from previous use.\n");
      }
      exit(1);
    }
    runControlPingWhileSleep(0.0, &loopParam);
    lastRCPingTime = getTimeInSecs();
    strcpy(rcParam.message, "Running");
    rcParam.status = runControlLogMessage(rcParam.handle, rcParam.message, NO_ALARM, &(rcParam.rcInfo));
    if (rcParam.status != RUNCONTROL_OK) {
      fprintf(stderr, "Unable tp write status message and alarm severity\n");
      exit(1);
    }
  }
#endif
  atexit(rc_interrupt_handler);

  waveforms = 0;
  ca_task_initialize();
  if (loopParam.verbose) {
    fprintf(FPINFO, "Reading input file and setup CA connection %s.\n", loopParam.inputfile);
    fflush(FPINFO);
  }
  readResponseDataAndIDsectorFile(responseFile, IDsectorFile, &resp_matrix, loopParam.pendIOTime);

  if (readinputfile(loopParam.inputfile, &waveforms, &waveformData, &loopParam, SCRFile, &resp_matrix)) {
    fprintf(stderr, "Error in reading file/setup CA connections\n");
    free_waveform_memory(waveforms, waveformData);
    exit(1);
  }

  /*********************
   * Iteration loop    *
   *********************/
  if (loopParam.verbose) {
    fprintf(FPINFO, "At %lf seconds starting loop of %ld steps.\n", getTimeInSecs() - startTime0, loopParam.steps);
    fflush(FPINFO);
  }
#ifdef USE_RUNCONTROL
  if (rcParam.PV) {
    strcpy(rcParam.message, "Iterations started");
    rcParam.status = runControlLogMessage(rcParam.handle, rcParam.message, NO_ALARM, &(rcParam.rcInfo));
    if (rcParam.status != RUNCONTROL_OK) {
      fprintf(stderr, "Unable to write status message and alarm severity\n");
      free_waveform_memory(waveforms, waveformData);
      exit(1);
    }
  }
#endif

  targetTime = getTimeInSecs();
  for (loopParam.step = 0; loopParam.step < loopParam.steps; loopParam.step++) {
    if (loopParam.verbose) {
      fprintf(stdout, "Step %ld at %f seconds\n", loopParam.step, getTimeInSecs() - startTime0);
      fflush(stdout);
    }
    /*read energy loss */
    for (i = 0; i < resp_matrix.IDs; i++) {
#ifdef USE_RUNCONTROL
      if (rcParam.PV) {
        if (getTimeInSecs() >= lastRCPingTime + 2) {
          lastRCPingTime = getTimeInSecs();
          runControlPingWhileSleep(0.0, &loopParam);
        }
      }
#endif
      if (ca_get(DBR_DOUBLE, resp_matrix.energyID[i], &resp_matrix.totalPower[i]) != ECA_NORMAL) {
        fprintf(stderr, "Error reading ID %s energy loss\n", resp_matrix.IDname[i]);
        ca_task_exit();
        exit(1);
      }
    }
    if (ca_pend_io(loopParam.pendIOTime) != ECA_NORMAL) {
      fprintf(stderr, "Error: problem doing put for some channels\n");
      exit(1);
    }
    /* The EPICS PV total power assume a fixed energy of 7GeV */
    /* For example, the actual power will be less at 6 GeV */
    for (i = 0; i < resp_matrix.IDs; i++) {
      resp_matrix.totalPower[i] *= sqr(beamEnergy / 7.0);
    }
#ifdef USE_RUNCONTROL
    if (rcParam.PV) {
      if (getTimeInSecs() >= lastRCPingTime + 2) {
        lastRCPingTime = getTimeInSecs();
        runControlPingWhileSleep(0.0, &loopParam);
      }
    }
#endif
    /* Compute matrix */
    /* Total power divided by beam energy and by stored current (100 mA) 
       gives relative energy loss in straight section */
    for (i = 0; i < resp_matrix.resp_rows; i++) {
      resp_matrix.delta_setpoint[i] = 0;
      for (j = 0; j < resp_matrix.IDs; j++)
        resp_matrix.delta_setpoint[i] += -1 * resp_matrix.resp_data[i][j] * resp_matrix.totalPower[j] * 10 / (beamEnergy * 1e9) * 1000;
    }
    for (i = 0; i < waveforms; i++) {
      for (j = 0; j < waveformData[i].waveformRows; j++) {
#ifdef USE_RUNCONTROL
        if (rcParam.PV) {
          if (getTimeInSecs() >= lastRCPingTime + 2) {
            lastRCPingTime = getTimeInSecs();
            runControlPingWhileSleep(0.0, &loopParam);
          }
        }
#endif
        if (waveformData[i].bpmIndex[j] >= 0)
          waveformData[i].setpoint[j] = waveformData[i].init_setpoint[j] + resp_matrix.delta_setpoint[waveformData[i].bpmIndex[j]];
        else
          waveformData[i].setpoint[j] = waveformData[i].init_setpoint[j];
        waveformData[i].waveformValue[j] = waveformData[i].setpoint[j] + waveformData[i].offset[j];
        if (!loopParam.dryRun) {
          if (waveformData[i].isValid[j]) {
            if (ca_put(DBR_DOUBLE, waveformData[i].setpointID[j], &(waveformData[i].setpoint[j])) != ECA_NORMAL ||
                ca_put(DBR_DOUBLE, waveformData[i].offsetID[j], &(waveformData[i].offset[j])) != ECA_NORMAL) {
              fprintf(stderr, "Error settting setpoint and offset pvs\n");
              exit(1);
            }
          }
        }
      }
      if (!loopParam.dryRun) {
        if (ca_array_put(DBR_DOUBLE, waveformData[i].waveformRows, waveformData[i].waveformCID, waveformData[i].waveformValue) != ECA_NORMAL) {
          fprintf(stderr, "Error setting waveform %s.\n", waveformData[i].waveformPV);
          exit(1);
        }
      }
    }
    if (!loopParam.dryRun) {
      if (ca_pend_io(loopParam.pendIOTime) != ECA_NORMAL) {
        fprintf(stderr, "Error1: problem doing put for some channels\n");
        exit(1);
      }
#ifdef USE_RUNCONTROL
      if (rcParam.PV) {
        if (getTimeInSecs() >= lastRCPingTime + 2) {
          lastRCPingTime = getTimeInSecs();
          runControlPingWhileSleep(0.0, &loopParam);
        }
      }
#endif
    }
    if (loopParam.verbose) {
      fprintf(stdout, "At %lf seconds, writing waveform pvs done.\n", getTimeInSecs() - startTime0);
      fflush(stdout);
    }

    targetTime += loopParam.interval;
    timeLeft = targetTime - getTimeInSecs();
    if (timeLeft < 0) {
      /* if the runcontrol PV had been paused for a long time, say, the target
         time is no longer valid, since it is substantially in the past.
         The target time should be reset to now.
      */
      targetTime = getTimeInSecs();
      timeLeft = 0;
    }
#ifdef USE_RUNCONTROL
    if (rcParam.PV) {
      lastRCPingTime = getTimeInSecs();
      runControlPingWhileSleep(timeLeft, &loopParam);
    } else {
      oag_ca_pend_event(timeLeft, &sigint);
    }
#else
    oag_ca_pend_event(timeLeft, &sigint);
#endif
  }
#ifdef USE_RUNCONTROL
  /* exit runcontrol */
  if (rcParam.PV) {
    switch (runControlExit(rcParam.handle, &(rcParam.rcInfo))) {
    case RUNCONTROL_OK:
      break;
    case RUNCONTROL_ERROR:
      fprintf(stderr, "Error exiting run control.\n");
      break;
    default:
      fprintf(stderr, "Unrecognized error return code from runControlExit.\n");
      break;
    }
  }
#endif
  ca_task_exit();
  free_response_memory(&resp_matrix);
  free_waveform_memory(waveforms, waveformData);
  free(responseFile);
  free(IDsectorFile);
  if (rcParam.PV)
    free(rcParam.PV);
  if (rcParam.Desc)
    free(rcParam.Desc);
  free_scanargs(&scArg, argc);
  return 0;
}

void InitializeLoopParam(LOOP_PARAM *loopParam) {
  loopParam->step = 0;
  loopParam->steps = 1;
  loopParam->verbose = 0;
  loopParam->searchPath = NULL;
  loopParam->interval = 0.5;
  loopParam->dryRun = 0;
  loopParam->elapsedTime = NULL;
  loopParam->epochTime = NULL;
  loopParam->pendIOTime = 30;
  loopParam->inputfile = NULL;
}

void interrupt_handler(int sig) {
  exit(1);
}

void sigint_interrupt_handler(int sig) {
  signal(SIGINT, interrupt_handler);
  signal(SIGTERM, interrupt_handler);
#ifndef _WIN32
  signal(SIGQUIT, interrupt_handler);
#endif
  sigint = 1;
  return;
}

void rc_interrupt_handler() {
  int ca = 1;
#ifndef EPICS313
  if (ca_current_context() == NULL)
    ca = 0;
  if (ca)
    ca_attach_context(ca_current_context());
#endif
  if (ca) {
#ifdef USE_RUNCONTROL
    if (rcParam.PV) {
      switch (runControlExit(rcParam.handle, &(rcParam.rcInfo))) {
      case RUNCONTROL_OK:
        break;
      case RUNCONTROL_ERROR:
        fprintf(stderr, "Error exiting run control.\n");
        break;
      default:
        fprintf(stderr, "Unrecognized error return code from runControlExit.\n");
        break;
      }
    }
#endif
    ca_task_exit();
  }
}

#ifdef USE_RUNCONTROL
int runControlPingWhileSleep(double sleepTime, LOOP_PARAM *loopParam) {
  double timeLeft;

  timeLeft = sleepTime;
  do {
    rcParam.status = runControlPing(rcParam.handle, &(rcParam.rcInfo));
    switch (rcParam.status) {
    case RUNCONTROL_ABORT:
      if (loopParam->verbose)
        fprintf(stderr, "Run control %s aborted.\n", rcParam.PV);
      exit(1);
      break;
    case RUNCONTROL_TIMEOUT:
      if (loopParam->verbose)
        fprintf(stderr, "Run control %s timed out.\n", rcParam.PV);
      sprintf(rcParam.message, "%s timed out", rcParam.PV);
      runControlLogMessage(rcParam.handle, rcParam.message, MAJOR_ALARM, &(rcParam.rcInfo));
      exit(1);
      break;
    case RUNCONTROL_OK:
      break;
    case RUNCONTROL_ERROR:
      if (loopParam->verbose)
        fprintf(stderr, "Communications error with runcontrol record.\n");
      return (RUNCONTROL_ERROR);
    default:
      if (loopParam->verbose)
        fprintf(stderr, "Unknown run control error code.\n");
      break;
    }
    oag_ca_pend_event(MIN(timeLeft, rcParam.pingInterval), &sigint);
    if (sigint)
      exit(1);
    timeLeft -= rcParam.pingInterval;
  } while (timeLeft > 0);
  return (RUNCONTROL_OK);
}
#endif

void free_waveform_memory(long waveforms, WAVEFORM_DATA *waveformData) {
  long i, j;
  for (i = 0; i < waveforms; i++) {
    free(waveformData[i].waveformPV);
    waveformData[i].waveformPV = NULL;
    for (j = 0; j < waveformData[i].waveformRows; j++)
      free(waveformData[i].DeviceName[j]);
    free(waveformData[i].DeviceName);
    waveformData[i].DeviceName = NULL;
    free(waveformData[i].waveformValue);
    waveformData[i].waveformValue = NULL;
    free(waveformData[i].setpoint);
    free(waveformData[i].offset);
    free(waveformData[i].init_setpoint);
    if (waveformData[i].setpointID)
      free(waveformData[i].setpointID);
    if (waveformData[i].offsetID)
      free(waveformData[i].offsetID);
    if (waveformData[i].isValid)
      free(waveformData[i].isValid);
    free(waveformData[i].bpmIndex);
  }
  free(waveformData);
  waveformData = NULL;
}

long readinputfile(char *inputfile, long *waveforms, WAVEFORM_DATA **waveformData, LOOP_PARAM *loopParam, char *SCRFile, RESPONSE_MATRIX *resp_matrix) {
  long i, j, pages;
  double lastRCPingTime = 0.0;
  char pvName[256];
  WAVEFORM_DATA *data = NULL;
  SDDS_TABLE SDDSin, SDDSscr;
  char **scrPVName = NULL, **valueString = NULL;
  int32_t scrRows = 0;

  *waveforms = 0;
  pages = 0;
  *waveformData = NULL;

  if (SCRFile) {
    if (!SDDS_InitializeInput(&SDDSscr, SCRFile))
      SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);
    if (SDDS_ReadPage(&SDDSscr) <= 0) {
      fprintf(stderr, "Error reading SCR file %s\n", SCRFile);
      exit(1);
    }
    scrRows = SDDS_RowCount(&SDDSscr);
    if (scrRows > 0) {
      if (!(scrPVName = (char **)SDDS_GetColumn(&SDDSscr, "ControlName")) ||
          !(valueString = (char **)SDDS_GetColumn(&SDDSscr, "ValueString")))
        SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);
    }
    if (!SDDS_Terminate(&SDDSscr))
      SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);
  }
  if (!SDDS_InitializeInput(&SDDSin, inputfile))
    SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);

  if ((SDDS_CHECK_OKAY != SDDS_CheckParameter(&SDDSin, "WaveformPV", NULL, SDDS_STRING, stderr))) {
    SDDS_SetError("Missing parameter Waveform in input file");
    SDDS_PrintErrors(stderr, SDDS_EXIT_PrintErrors | SDDS_VERBOSE_PrintErrors);
  }
  if ((SDDS_CHECK_OKAY != SDDS_CheckColumn(&SDDSin, "DeviceName", NULL, SDDS_STRING, stderr))) {
    SDDS_SetError("Missing column DeviceName in input file");
    SDDS_PrintErrors(stderr, SDDS_EXIT_PrintErrors | SDDS_VERBOSE_PrintErrors);
  }
  pages = 0;
  while (SDDS_ReadPage(&SDDSin) > 0) {
#ifdef USE_RUNCONTROL
    if (rcParam.PV) {
      if (getTimeInSecs() >= lastRCPingTime + 2) {
        lastRCPingTime = getTimeInSecs();
        /* ping once at the beginning */
        if (runControlPingWhileSleep(0.0, loopParam)) {
          fprintf(stderr, "Problem pinging the run control record.\n");
          return (1);
        }
      }
    }
#endif
    if (!(data = SDDS_Realloc(data, sizeof(*data) * (pages + 1))))
      SDDS_Bomb("memory allocation failure");
    if (((data)[pages].waveformRows = SDDS_RowCount(&SDDSin)) <= 0)
      continue;
    data[pages].waveformPV = NULL;
    data[pages].isValid = NULL;
    data[pages].bpmIndex = NULL;
    data[pages].DeviceName = NULL;
    data[pages].setpointID = data[pages].offsetID = NULL;
    data[pages].waveformValue = NULL;
    data[pages].setpoint = data[pages].offset = data[pages].init_setpoint = NULL;
    if (!(SDDS_GetParameter(&SDDSin, "WaveformPV", &data[pages].waveformPV)) ||
        !(data[pages].DeviceName = (char **)SDDS_GetColumn(&SDDSin, "DeviceName")))
      SDDS_PrintErrors(stderr, SDDS_EXIT_PrintErrors | SDDS_VERBOSE_PrintErrors);
    data[pages].bpmIndex = malloc(sizeof(int32_t) * data[pages].waveformRows);
    data[pages].waveformValue = malloc(sizeof(double) * data[pages].waveformRows);
    data[pages].setpointID = malloc(sizeof(chid) * data[pages].waveformRows);
    data[pages].offsetID = malloc(sizeof(chid) * data[pages].waveformRows);
    data[pages].isValid = malloc(sizeof(short) * data[pages].waveformRows);
    data[pages].setpoint = malloc(sizeof(double) * data[pages].waveformRows);
    data[pages].init_setpoint = malloc(sizeof(double) * data[pages].waveformRows);
    data[pages].offset = malloc(sizeof(double) * data[pages].waveformRows);
    for (i = 0; i < data[pages].waveformRows; i++) {
      data[pages].isValid[i] = 1;
      data[pages].bpmIndex[i] = match_string(data[pages].DeviceName[i], resp_matrix->bpmName, resp_matrix->resp_rows, EXACT_MATCH);
      /* fprintf(stderr, "%s index %d\n", data[pages].DeviceName[i], data[pages].bpmIndex[i]); */
      if (scrRows) {
        sprintf(pvName, "%s:ms:x:SetpointAO", data[pages].DeviceName[i]);
        if ((j = match_string(pvName, scrPVName, scrRows, EXACT_MATCH)) >= 0) {
          data[pages].init_setpoint[i] = atof(valueString[j]);
        } else
          data[pages].isValid[i] = 0;
        sprintf(pvName, "%s:ms:x:OffsetAO", data[pages].DeviceName[i]);
        if ((j = match_string(pvName, scrPVName, scrRows, EXACT_MATCH)) >= 0) {
          data[pages].offset[i] = atof(valueString[j]);
        } else {
          data[pages].isValid[i] = 0;
        }
      }
      /*S37 to 40 P0s does not exist */
      if (wild_match(data[pages].DeviceName[i], "S37*:P0") || wild_match(data[pages].DeviceName[i], "S38*:P0") || wild_match(data[pages].DeviceName[i], "S39*:P0") ||
          wild_match(data[pages].DeviceName[i], "S40*:P0") || wild_match(data[pages].DeviceName[i], "Spare*"))
        data[pages].isValid[i] = 0;
    }
    pages++;
  }
  if (!SDDS_Terminate(&SDDSin))
    SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);

  if (SCRFile) {
    if (scrRows) {
      SDDS_FreeStringArray(scrPVName, scrRows);
      SDDS_FreeStringArray(valueString, scrRows);
      free(scrPVName);
      free(valueString);
    }
  }
  for (i = 0; i < pages; i++) {
#ifdef USE_RUNCONTROL
    if (rcParam.PV) {
      if (getTimeInSecs() >= lastRCPingTime + 2) {
        lastRCPingTime = getTimeInSecs();
        runControlPingWhileSleep(0.0, loopParam);
      }
    }
#endif
    if (ca_search(data[i].waveformPV, &(data[i].waveformCID)) != ECA_NORMAL) {
      fprintf(stderr, "Error: problem doing search for %s\n", data[i].waveformPV);
      ca_task_exit();
      exit(1);
    }
    for (j = 0; j < data[i].waveformRows; j++) {
#ifdef USE_RUNCONTROL
      if (rcParam.PV) {
        if (getTimeInSecs() >= lastRCPingTime + 2) {
          lastRCPingTime = getTimeInSecs();
          runControlPingWhileSleep(0.0, loopParam);
        }
      }
#endif
      if (data[i].isValid[j]) {
        sprintf(pvName, "%s:ms:x:SetpointAO", data[i].DeviceName[j]);
        if (ca_search(pvName, &(data[i].setpointID[j])) != ECA_NORMAL) {
          fprintf(stderr, "Error: problem doing search for %s\n", pvName);
          ca_task_exit();
          exit(1);
        }
        sprintf(pvName, "%s:ms:x:OffsetAO", data[i].DeviceName[j]);
        if (ca_search(pvName, &(data[i].offsetID[j])) != ECA_NORMAL) {
          fprintf(stderr, "Error: problem doing search for %s\n", pvName);
          ca_task_exit();
          exit(1);
        }
      }
    }
  }
  /*after connecting all pvs */
  if (ca_pend_io(loopParam->pendIOTime) != ECA_NORMAL) {
    fprintf(stderr, "Error: problem doing search for some channels\n");
    for (i = 0; i < pages; i++) {
      if (ca_state(data[i].waveformCID) != cs_conn)
        fprintf(stderr, "%s not connected\n", data[i].waveformPV);
      for (j = 0; j < data[i].waveformRows; j++) {
        /*remove illegal device names such as 16, Illigal for FF setpoint waveform */
        if (data[i].isValid[j]) {
          sprintf(pvName, "%s:ms:x:SetpontAO", data[i].DeviceName[j]);
          if (ca_state(data[i].setpointID[j]) != cs_conn)
            fprintf(stderr, "%s not connected\n", pvName);
          sprintf(pvName, "%s:ms:x:OffsetAO", data[i].DeviceName[j]);
          if (ca_state(data[i].offsetID[j]) != cs_conn)
            fprintf(stderr, "%s not connected\n", pvName);
        }
      }
    }
    ca_task_exit();
    return (1);
  }
  for (i = 0; i < pages; i++) {
    if (ca_array_get(DBR_DOUBLE, data[i].waveformRows, data[i].waveformCID, data[i].waveformValue) != ECA_NORMAL) {
      fprintf(stderr, "Error READING waveform %s.\n", data[i].waveformPV);
      exit(1);
    }
    if (!scrRows) {
      /*if SCR file not provided, then read setpoint and offset from ioc */
      for (j = 0; j < data[i].waveformRows; j++) {
        if (data[i].isValid[j]) {
          if (ca_get(DBR_DOUBLE, data[i].setpointID[j], &data[i].init_setpoint[j]) != ECA_NORMAL ||
              ca_get(DBR_DOUBLE, data[i].offsetID[j], &data[i].offset[j]) != ECA_NORMAL) {
            fprintf(stderr, "Error reading setpoint and offset pvs!\n");
            exit(1);
          }
        }
      }
    }
  }

  if (ca_pend_io(loopParam->pendIOTime) != ECA_NORMAL) {
    fprintf(stderr, "Error: problem doing search for some channels\n");
    exit(1);
  }

  *waveformData = data;
  *waveforms = pages;
  return (0);
}

void readResponseDataAndIDsectorFile(char *respFile, char *IDsectorFile, RESPONSE_MATRIX *resp_matrix, double pendIOTime) {
  SDDS_DATASET SDDSin, SDDSresp;
  int32_t *us = NULL, *ds = NULL, *sector = NULL;
  int32_t IDrows, i, j, respRows, IDs = 0;
  char pvName[256], col_name[256];
  double **value = NULL;

  resp_matrix->IDs = resp_matrix->resp_rows = 0;
  resp_matrix->bpmName = NULL;
  resp_matrix->resp_data = NULL;
  resp_matrix->energyID = NULL;
  resp_matrix->totalPower = NULL;
  resp_matrix->IDname = NULL;

  if (!SDDS_InitializeInput(&SDDSin, IDsectorFile))
    SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);
  if (SDDS_ReadPage(&SDDSin) <= 0) {
    fprintf(stderr, "Error reading ID sector file %s\n", IDsectorFile);
    exit(1);
  }
  if (!SDDS_InitializeInput(&SDDSresp, respFile))
    SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);
  if (SDDS_ReadPage(&SDDSresp) <= 0) {
    fprintf(stderr, "Error reading ID sector file %s\n", respFile);
    exit(1);
  }

  IDs = 0;
  IDrows = SDDS_RowCount(&SDDSin);
  respRows = SDDS_RowCount(&SDDSresp);
  if (!(ds = SDDS_GetColumnInLong(&SDDSin, "Downstream")) ||
      !(us = SDDS_GetColumnInLong(&SDDSin, "Upstream")) ||
      !(sector = SDDS_GetColumnInLong(&SDDSin, "Sector")) ||
      !SDDS_Terminate(&SDDSin))
    SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);

  resp_matrix->resp_rows = respRows;
  resp_matrix->resp_data = malloc(sizeof(*resp_matrix->resp_data) * respRows);
  resp_matrix->delta_setpoint = malloc(sizeof(double) * respRows);
  if (!(resp_matrix->bpmName = (char **)SDDS_GetColumn(&SDDSresp, "ElementName")))
    SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);

  resp_matrix->energyID = malloc(sizeof(chid) * IDrows * 2);
  resp_matrix->totalPower = malloc(sizeof(double) * IDrows * 2);
  resp_matrix->IDname = malloc(sizeof(*resp_matrix->IDname) * IDrows * 2);
  value = malloc(sizeof(*value) * IDrows * 2);
  IDs = 0;
  for (i = 0; i < IDrows; i++) {
    if (us[i]) {
      sprintf(col_name, "ID%02dus", sector[i]);
      sprintf(pvName, "ID%02dus:TotalPower", sector[i]);
      SDDS_CopyString(&resp_matrix->IDname[IDs], pvName);
      if (ca_search(pvName, &resp_matrix->energyID[IDs]) != ECA_NORMAL) {
        fprintf(stderr, "Error: problem doing search for %s\n", pvName);
        ca_task_exit();
        exit(1);
      }
      value[IDs] = NULL;
      if (!(value[IDs] = SDDS_GetColumnInDoubles(&SDDSresp, col_name)))
        SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);
      IDs++;
    }
    if (ds[i]) {
      sprintf(col_name, "ID%02dds", sector[i]);
      sprintf(pvName, "ID%02dds:TotalPower", sector[i]);
      SDDS_CopyString(&resp_matrix->IDname[IDs], pvName);
      if (ca_search(pvName, &resp_matrix->energyID[IDs]) != ECA_NORMAL) {
        fprintf(stderr, "Error: problem doing search for %s\n", pvName);
        ca_task_exit();
        exit(1);
      }
      value[IDs] = NULL;
      if (!(value[IDs] = SDDS_GetColumnInDoubles(&SDDSresp, col_name)))
        SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);
      IDs++;
    }
  }
  if (!SDDS_Terminate(&SDDSresp))
    SDDS_PrintErrors(stderr, SDDS_VERBOSE_PrintErrors | SDDS_EXIT_PrintErrors);
  resp_matrix->IDs = IDs;
  /*assign matrix to each bpm (transpose matrix) */
  for (i = 0; i < respRows; i++) {
    resp_matrix->resp_data[i] = malloc(sizeof(double) * resp_matrix->IDs);
    for (j = 0; j < IDs; j++)
      resp_matrix->resp_data[i][j] = value[j][i];
  }
  free(sector);
  free(ds);
  free(us);
  /*assign matrix to each bpm (transpose matrix) */
  for (i = 0; i < IDs; i++)
    if (value[i])
      free(value[i]);
  free(value);
  if (ca_pend_io(pendIOTime) != ECA_NORMAL) {
    fprintf(stderr, "error1: problem doing search for some ID channels\n");
    for (i = 0; i < IDs; i++) {
      if (ca_state(resp_matrix->energyID[i]) != cs_conn)
        fprintf(stderr, "%s not connected\n", resp_matrix->IDname[i]);
    }
    exit(1);
  }
}

void free_response_memory(RESPONSE_MATRIX *resp_matrix) {
  long i, j;
  for (i = 0; i < resp_matrix->resp_rows; i++) {
    free(resp_matrix->resp_data[i]);
    free(resp_matrix->bpmName[i]);
  }
  free(resp_matrix->resp_data);
  free(resp_matrix->bpmName);
  for (j = 0; j < resp_matrix->IDs; j++)
    free(resp_matrix->IDname[j]);
  free(resp_matrix->IDname);
  free(resp_matrix->delta_setpoint);
  free(resp_matrix->totalPower);
  free(resp_matrix->energyID);
}
